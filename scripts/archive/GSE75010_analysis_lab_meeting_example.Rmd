---
title: "GSE75010_merged_analysis"
author: "Kyle Campbell"
date: "10/20/2020"
output: html_document
---
```{r setup, include=FALSE}
library(tidyverse)
library(betareg)
library(boot)
library(car)
library(DT)
library(lmtest)
#library(memisc)
# Had to detach memisc due to shared function with dplyr that producing annoying warning
library(psych)
library(readxl)
library(table1)
library(tidymodels)
knitr::opts_chunk$set(echo = TRUE)
data_dir <- "C:/Users/k_cam/Downloads/scRNA_hpc_qc/"
```
## Iris example.
```{r}
iris %>% as_tibble
```
```{r}
iris %>%
  group_by(Species) %>%
  summarise(avg = mean(Sepal.Width)) %>%
  arrange(avg)
```


```{r}
merged <- readRDS(paste0(data_dir, "GSE75010_merged_abundances2020-10-21.rda"))
```
## table1 R package

table1 r package to do descriptive statistics
https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html

Need to create an empty stratum called P-value for the variable you want to test by.
```{r}
t1 <- merged
# Factorize phenotype
t1$phenotype <- factor(t1$phenotype, levels = c("C", "PE", "99"), labels = c("Control", "Preeclampsia", "P-value"))
# Factorize sex
t1$sex <- factor(t1$sex, levels = c("F", "M"), labels = c("Female", "Male"))

# Label columns heads for t1
label(t1$phenotype) <- "Preeclampsia"
label(t1$sex) <- "Sex"
label(t1$batch) <- "Study"
label(t1$ga) <- "Gestational Age"

# Provides units for numeric entries
units(t1$ga) <- "wks"
```
Custom code from the package authors to add p-value column. An empty stratum called P-value is required for the variable you are testing. rndr function will need to be adpated to each specific situation, including the entering the dataframe you wish to use and the statistical test to use for numeric and non-numeric columns. rndr.strat does not need to be modified. https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html#a-column-of-p-values 
```{r}
rndr <- function(x, name, ...) {
    if (length(x) == 0) {
        # RHS needs to correspond to the dataframe you input to t1()
        y <- t1[[name]]
        s <- rep("", length(render.default(x=y, name=name, ...)))
        if (is.numeric(y)) {
            # RHS needs to correspond to the dataframe you input to t1()
            # If the column is numeric, set the desired statistical test, T-test here 
            p <- t.test(y ~ t1$phenotype)$p.value
        } else {
            #Again droplevels() argument needs to be the dataframe you input to t1()
            # If the column is not numeric, set the desired statistical test, Chi-square here
            p <- chisq.test(table(y, droplevels(t1$phenotype)))$p.value
        }
        s[2] <- sub("<", "&lt;", format.pval(p, digits=3, eps=0.001))
        s
    } else {
        render.default(x=x, name=name, ...)
    }
}

rndr.groups <- function(x, name, ...) {
    if (length(x) == 0) {
        # RHS needs to correspond to the dataframe you input to t1()
        y <- t1[[name]]
        s <- rep("", length(render.default(x=y, name=name, ...)))
        if (is.numeric(y)) {
            # RHS needs to correspond to the dataframe you input to t1()
            # If the column is numeric, set the desired statistical test, Kruskal-Wallis here 
            p <- kruskal.test(y ~ t1$batch)$p.value
        } else {
            #Again droplevels() argument needs to be the dataframe you input to t1()
            # If the column is not numeric, set the desired statistical test, Chi-square here
            p <- chisq.test(table(y, droplevels(t1$batch)))$p.value
        }
        s[2] <- sub("<", "&lt;", format.pval(p, digits=3, eps=0.001))
        s
    } else {
        render.default(x=x, name=name, ...)
    }
}

rndr.strat <- function(label, n, ...) {
    ifelse(n==0, label, render.strat.default(label, n, ...))
}
```
Bivariate outcome with t-test for continuous variables and Chi-square test for categorical outcomes.
```{r}
table1(~ sex + ga + batch | phenotype, data=t1, droplevels=F, render=rndr, render.strat=rndr.strat, overall=F)
```
## Graphing cell type proportion estimates
Convert to long data format for graphing purposes
```{r}
# Remove the unnecessary columns
# Select was masked, had to add dplyr::
merged.violin <- merged %>% dplyr::select(!c(batch, ga, sex, p_value, correlation, rmse))

# Convert to long-form for graphing
long <- gather(merged.violin, key = cell_type, value = proportion, fibroblasts:extravillous_trophoblasts, factor_key = T)
long.placenta <- long %>%
  dplyr::filter(cell_type %in% c("fibroblasts", "cytotrophoblasts", "hofbauer_cells", "endothelial_cells", "synctyiotrophoblast", "npicytotrophoblasts", "extravillous_trophoblasts"))
long.immune <- long %>%
  dplyr::filter(!cell_type %in% c("fibroblasts", "cytotrophoblasts", "hofbauer_cells", "endothelial_cells", "synctyiotrophoblast", "npicytotrophoblasts", "extravillous_trophoblasts"))
```
scale = "width" argument required rather than ggplot2 default of scale = "area" for this dataset
TODO cleanup x-axis label
```{r}
ggplot(long.placenta, aes(x = cell_type, y = proportion, fill = phenotype)) +
  geom_violin(scale = "width", draw_quantiles = c(0.25, 0.5, 0.75)) +
  theme(legend.position = c(.1, .8)) +
  theme(axis.text.x = element_text(angle = 45))
#ggsave(paste0(data_dir, "vln_placenta.png"), device = png())
```

```{r}
ggplot(long.immune, aes(x = cell_type, y = proportion, fill = phenotype)) +
  geom_violin(scale = "width", draw_quantiles = c(0.25, 0.5, 0.75)) +
  theme(legend.position = c(.1, .8)) +
  theme(axis.text.x = element_text(angle = 45))
#ggsave(paste0(data_dir, "vln_immune.png"), device = png())
```
Beta transformation function to accomodate 0's in the cell types where 0's are predicted.
```{r}
beta_transform <- function(x, n) {
  return((1/n)*(x*(n-1)+0.5))
}
```
Function to run beta regressions over the outcomes of interest.
```{r}
# run beta regression models with multiple outcomes, the same set of covariates, and a dataset that includes all outcomes and covariates.
# outcomes is a character vector
# covariates is a character vector
# data is a 2d dataframe suitable for regression
beta_reg_models <- function(outcomes, covariates, data) {
  # Initialize empty list to store fitted regression models
  models <- list()
  # Loop over outcomes of interest
  for(outcome in outcomes) {
    # transform the data to accomodate 0s for beta regression if necessary
    if (0 %in% data[, outcome]) {
      data[, outcome] <- beta_transform(data[, outcome], nrow(data))
    }
    formula <- as.formula(
      paste0(outcome, " ~ ", paste(covariates, collapse = " + "))
    )
    models[[outcome]] <- tidy(x = betareg(formula = formula, data = data),
                              data = data,
                              conf.int = TRUE,
                              conf.level = .95)
  }
  return(models)
}

# Same function as above but returns model fit statistics
beta_reg_model_fits <- function(outcomes, covariates, data) {
  # Initialize empty list to store fitted regression models
  model_fits <- list()
  # Loop over outcomes of interest
  for(outcome in outcomes) {
    # transform the data to accomodate 0s for beta regression if necessary
    if (0 %in% data[, outcome]) {
      data[, outcome] <- beta_transform(data[, outcome], nrow(data))
    }
    formula <- as.formula(
      paste0(outcome, " ~ ", paste(covariates, collapse = " + "))
    )
    model_fits[[outcome]] <- glance(x = betareg(formula = formula, data = data), data = data)
  }
  return(model_fits)
}
```
Run a model across all the cell types.
```{r}
# Set the covariates vector, including the exposure at the front
covariates <- c("phenotype", "sex", "ga", "batch")
models <- beta_reg_models(cell.types, covariates, merged)
fits <- beta_reg_model_fits(cell.types, covariates, merged)
```
Pull all model effect estimates and combine to a single tibble for graphing.
```{r}
pull_estimates <- function(data) {
  return(
    data %>%
      filter(term == "phenotypePE") %>%
      dplyr::select(estimate,
                    conf.low,
                    conf.high,
                    p.value) %>%
      mutate(
        or = exp(estimate),
        lower = exp(conf.low),
        upper = exp(conf.high)
      )
  )
}
estimates <- lapply(X = models, FUN = pull_estimates)
# Collapse list of model estimates to a single tibble
estimates <- Reduce(rbind, estimates)
# Add cell_type names and reorganize columns
estimates <-
  estimates %>%
  mutate(cell_type = names(models)) %>%
  dplyr::select(cell_type, everything())
#write.csv(estimates, paste0(data_dir, "model_data.csv"))
estimates
```
John's Forest plot code
```{r}
forest <- ggplot(data=estimates, aes(x=cell_type, y=or, ymin=lower, ymax=upper)) +
    geom_pointrange(aes(col=cell_type), position=position_dodge2(width=1), size=1.3) +
    geom_hline(yintercept=1, linetype=2) +
    theme_bw() +
    theme(text = element_text(size=20), legend.position = 'none') +
    xlab('') + ylab('Odds Ratio') +
    coord_flip()
#ggsave(paste0(data_dir, "forest.png"), device = png())
forest
```